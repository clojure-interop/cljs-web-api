// Compiled by ClojureScript 1.9.946 {}
goog.provide('web.ConstantSourceNode');
goog.require('cljs.core');
/**
 * Constructor.
 * 
 *   The ConstantSourceNode() constructor creates a new `web.ConstantSourceNode` object instance, representing an audio source which constantly outputs samples whose values are always the same.
 * 
 *   context
 *   An `audio.AudioContext` representing the audio context you want the node to be associated with.
 *   options
 *   A ConstantSourceOptions dictionary object defining the properties you want the ConstantSourceNode to have:
 * 
 *   offset: A read-only `audio.AudioParam` specifying the constant value generated by the source. The default is 1.0. The normal range is -1.0 to 1.0, but the value can be anywhere in the range from -Infinity to +Infinity.
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/ConstantSourceNode/ConstantSourceNode`
 */
web.ConstantSourceNode.constructor$ = ConstantSourceNode;
/**
 * Method.
 * 
 *   `web.undefined`
 * 
 *   `AudioScheduledSourceNode.start([when [, offset [, duration]]]);`
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/AudioScheduledSourceNode/start`
 */
web.ConstantSourceNode.start = (function web$ConstantSourceNode$start(var_args){
var args__42563__auto__ = [];
var len__42556__auto___44462 = arguments.length;
var i__42557__auto___44463 = (0);
while(true){
if((i__42557__auto___44463 < len__42556__auto___44462)){
args__42563__auto__.push((arguments[i__42557__auto___44463]));

var G__44464 = (i__42557__auto___44463 + (1));
i__42557__auto___44463 = G__44464;
continue;
} else {
}
break;
}

var argseq__42564__auto__ = ((((1) < args__42563__auto__.length))?(new cljs.core.IndexedSeq(args__42563__auto__.slice((1)),(0),null)):null);
return web.ConstantSourceNode.start.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__42564__auto__);
});

web.ConstantSourceNode.start.cljs$core$IFn$_invoke$arity$variadic = (function (this$,args){
return cljs.core.apply.call(null,this$.start,cljs.core.concat.call(null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [this$], null),args));
});

web.ConstantSourceNode.start.cljs$lang$maxFixedArity = (1);

web.ConstantSourceNode.start.cljs$lang$applyTo = (function (seq44460){
var G__44461 = cljs.core.first.call(null,seq44460);
var seq44460__$1 = cljs.core.next.call(null,seq44460);
return web.ConstantSourceNode.start.cljs$core$IFn$_invoke$arity$variadic(G__44461,seq44460__$1);
});

/**
 * Method.
 * 
 *   The stop() method on `audio.AudioScheduledSourceNode` schedules
 *   sound to cease playback at the specified time. If no time is
 *   then the sound stops playing immediately.
 * 
 *   `AudioScheduledSourceNode.stop([when]);`
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/AudioScheduledSourceNode/stop`
 */
web.ConstantSourceNode.stop = (function web$ConstantSourceNode$stop(var_args){
var args__42563__auto__ = [];
var len__42556__auto___44467 = arguments.length;
var i__42557__auto___44468 = (0);
while(true){
if((i__42557__auto___44468 < len__42556__auto___44467)){
args__42563__auto__.push((arguments[i__42557__auto___44468]));

var G__44469 = (i__42557__auto___44468 + (1));
i__42557__auto___44468 = G__44469;
continue;
} else {
}
break;
}

var argseq__42564__auto__ = ((((1) < args__42563__auto__.length))?(new cljs.core.IndexedSeq(args__42563__auto__.slice((1)),(0),null)):null);
return web.ConstantSourceNode.stop.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__42564__auto__);
});

web.ConstantSourceNode.stop.cljs$core$IFn$_invoke$arity$variadic = (function (this$,args){
return cljs.core.apply.call(null,this$.stop,cljs.core.concat.call(null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [this$], null),args));
});

web.ConstantSourceNode.stop.cljs$lang$maxFixedArity = (1);

web.ConstantSourceNode.stop.cljs$lang$applyTo = (function (seq44465){
var G__44466 = cljs.core.first.call(null,seq44465);
var seq44465__$1 = cljs.core.next.call(null,seq44465);
return web.ConstantSourceNode.stop.cljs$core$IFn$_invoke$arity$variadic(G__44466,seq44465__$1);
});

/**
 * Property.
 * 
 *   The read-only offset property of the `web.ConstantSourceNode`
 *   returns a `audio.AudioParam` object indicating the numeric a-rate
 *   which is always returned by the source when asked for the next
 * 
 *   `let offsetParameter = ConstantAudioNode.offset;
 * 
 *   let offset = ConstantSourceNode.offset.value;
 *   ConstantSourceNode.offset.value = newValue;`
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/ConstantSourceNode/offset`
 */
web.ConstantSourceNode.offset = (function web$ConstantSourceNode$offset(this$){
return this$.offset();
});
/**
 * Property.
 * 
 *   The onended event handler for the AudioScheduledSourceNode interface
 *   an `web.EventHandler` to be executed when the ended event occurs
 *   the node. This event is sent to the node when the concrete interface
 *   as `audio.AudioBufferSourceNode`, `web.OscillatorNode`, or `web.ConstantSourceNode`)
 *   that it has stopped playing.
 * 
 *   `AudioScheduledSourceNode.onended = EventHandler;`
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/AudioScheduledSourceNode/onended`
 */
web.ConstantSourceNode.onended = (function web$ConstantSourceNode$onended(this$){
return this$.onended();
});
/**
 * Property.
 * 
 *   The onended event handler for the AudioScheduledSourceNode interface
 *   an `web.EventHandler` to be executed when the ended event occurs
 *   the node. This event is sent to the node when the concrete interface
 *   as `audio.AudioBufferSourceNode`, `web.OscillatorNode`, or `web.ConstantSourceNode`)
 *   that it has stopped playing.
 * 
 *   `AudioScheduledSourceNode.onended = EventHandler;`
 * 
 *   See also: `https://developer.mozilla.org/en-US/docs/Web/API/AudioScheduledSourceNode/onended`
 */
web.ConstantSourceNode.set_onended_BANG_ = (function web$ConstantSourceNode$set_onended_BANG_(this$,val){
return (this$["onended"] = val);
});

//# sourceMappingURL=ConstantSourceNode.js.map?rel=1565798814283
